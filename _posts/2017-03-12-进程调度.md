---
layout: post
title: "进程调度与切换"
tags: "进程调度", "进程", "CFS"
date: 2017-03-12
---

# 进程调度与切换
----------
### 进程调度需要考虑的具体问题：  
1. 调度的时机：在什么情况、什么时候进行调度
2. 调度的策略：根据什么准则选择下一个进程运行
3. 调度的方式：可剥夺 or 不可剥夺 

进程状态转换图：
![进程状态转换图](http://i.imgur.com/AIPJunP.png)

### 调度的时机
进程的调度是 **自愿的** ，自愿的调度随时都可以进行。一个进程可以通过 `schedule()` 启动一次调度，也可以在调用 `schedule()` 之前暂时放弃运行而进入阻塞状态。在用户空间中，可以通过系统调用 `pause()` 达到同样的目的。 

调度还可以是 **非自愿的** ，强制的发生在每次从系统调用返回的前夕，以及每次从中断或异常处理 **返回到用户空间** 的前夕。从系统空间返回到用户空间只是调度发生的必要条件，而不是充分条件。具体是否发生调度还要看有无此种要求。在系统空间也可能发生中断或异常，但这种中断或异常不会引起调度。

调度发生的时机：  

1. 通过系统调用资源让出运行
2. 系统调用中因某种原因受阻
3. 因某种原因唤醒一个进程
4. 时钟中断服务程序发现当前进程运行太久

### 调度策略：  
**SCHED_FIFO**：不使用时间片，进程处于可执行状态就一直执行，直到自己受到阻塞或显示的释放处理器为止。只有更高优先级的 `SCHED_FIFO`或者 `SCHED_RR` 任务才能抢占 `SCHED_FIFO` 任务。相同优先级的进程，会轮流执行，依然只有在愿意让出处理器时才退出。  

**SCHED_RR**： `SCHED_RR` 是带有时间片的 `SCHED_FIFO`，进程在消耗完实现非配给它的时间片之后就不能再继续执行。时间片只是用来重新调度同一优先级的进程。低优先级的进程决不能抢占 `SCHED_RR` 任务，即使它的时间片耗尽。  

**SCHED_NORMAL**： 传统的调度策略

### 进程切换：  
对用户虚存空间的处理

1. 如果新进程没有自己的 `mm_struct`(内核线程)，就要在进入运行时向被切换出去的进程借用一个 `mm_struct`结构，进行系统空间的映射，因为 **所有进程的系统空间映射都是相同的** 。  
2. 如果一个新进程有自己的用户空间，就通过 `switch_mm` 进行用户空间的切换
  
进程的切换 `switch_to()`

1. 将新进程页面目录的起始物理地址装入控制寄存器 CR3 
2. 切换内核栈和硬件上下文(寄存器数据)的切换，是进程切换的主要工作


[进程和线程切换](http://www.cnblogs.com/kkshaq/p/4547725.html)
切换的性能消耗：

1. 线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。
2. 另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。

时间片轮转  
短作业优先  

---

CFS 使用红黑树组织可运行队列  
等待队列：简单链表  
响应时间、系统利用率  
没有可运行的进程，CFS 调度器会选择 idle 任务运行  


[Linux进程管理与调度](https://github.com/gatieme/LDD-LinuxDeviceDrivers/tree/master/study/kernel/01-process)

[Linux调度器源码分析](http://www.cnblogs.com/tolimit/p/4303052.html)

[虚拟运行时间的计算公式](http://blog.csdn.net/ustc_dylan/article/details/7303851)

1. 虚拟运行时间计算公式

		vruntime += delta * (1024/se.load.weight);  
		// delta：进程实际增加的运行时间
		// 即从调度实体被选择获得cpu到调度实体放弃CPU这段时间
		// 在实际运行时间相同的情况下，调度实体权重越大，vruntime增加的越慢

2. 进程理想运行时间计算公式  
   slice为CFS运行队列中所有进程运行一遍所需要的时间  
		
		ideal_time = slice *(se.load.weight/cfs_rq.load.weight);
		//slice 计算公式
		if(cfs_rq->nr_running > 5)
			slice = 4 * cfs_rq->nr_running;
		else
 		   	slice = 20; //单位ms