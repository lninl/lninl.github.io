---
layout: post
title: "进程"
date: 2017-03-12
---

### 进程

##### 进程的组成
可执行文件
进程的系统空间堆栈
进程控制块
独立的存储空间

##### 进程控制块与系统空间堆栈
在物理存储空间上连在一起
分配两个连续的物理页面
底部用作进程控制块的结构 1K
上面用作系统空间堆栈 7K (省着用)

##### 进程控制块 (PCB) 
	状态：
		运行态、阻塞态(深|浅)、挂起、调试
		标志位
	性质：
		权限
	资源：
		资源限制、统计信息
		mm、active_mm、fs、files、...
	组织：
		进程关系，父子、兄弟，...

### 进程的创建 fork()、vfork()、clone()

##### task_struct 数据结构的复制与初始化

拷贝资源 **files、fs、sighand、mm**

* files 有条件的复制一打开文件的控制结构
* fs 进程的根目录root、当前工作目录pwd、文件操作权限管理的umask、计数器
* 内核线程不拥有用户空间、所以mm指针为0
* mm_struct 进行深拷贝，区间、映射、逐层处理页面目录和页面表
	* 映射已建立，增加磁盘页面的引用计数
	* 复制父进程的可写页面时，使用 COW 技术
 
> **写时拷贝(copy on write):** 
>
>* COW 的范畴：虚存区间的性质是可写而不是共享
>* COW 的实现：通过复制页面表项暂时共享一个页面
>	 * 将父进程的页面表项改为写保护
>	 * 把已经写保护的表项设置到子进程的页面表中
>* 经过 COW ，相应页面在两个进程中都变成"只读"了;父进程或子进程企图写入页面都会引起页面异常;异常处理程序另行分配一个物理页面，把内容真正的"复制"到新页面;然后将两个页面表中相应的表项改为可写
>
> **COW 只有在父、子进程各自拥有自己的页面表时才能实现** 

##### 内核栈的复制 copy_thread() 
>寄存器eax、内核栈不同于父进程

* 复制父进程的系统空间堆栈，堆栈中的内容说明了父进程从通过系统调用进入系统空间开始到进入 copy_thread() 的来历，子进程将要循相同的路线返回。
* 为区分父、子进程，调整子进程的内核栈
	* 将当前内核栈中的 pt_regs 结构复制到子进程内核栈中
		* pt_regs 保存进入内核前夕各寄存器的内容
	* 将结构中的 eax 置为 0 (子进程返回 0)
	* esp、依然指向父进程原来的用户空间堆栈。clone()中，调用者定
	* 调整子进程的 thread_struct 结构，指向自己的内核栈
		* thread_struct 里面记录着进程切换时内核栈的的指针
		* esp 设置为子进程内核栈的起始地址
		* esp0 指向子进程的内核栈顶端 (情景分析 P306)
		* eip 表示进程下一次被切换进入运行态的切入点

>将子进程的时间配合分两半，父、子进程各有原值的一半
>
>将子进程"唤醒"，即挂入可执行进程队列等待调度
>
>do_fork() 的参数 CLONE_VFORK 标志为 1 时，保证子进程先运行
>
	* 父进程执行一次 down() 操作 (信号量资源数量为 0)
	* 子进程执行 execve() or exit() 执行一次 up() 唤醒父进程

> fork()、vfork()、clone() 的区别
> 
	* 三个系统调用都是通过 do_fork() 完成，不同的只是调用参数
	* fork() 四项(files、fs、sighand、mm)资源全部复制
	* vfork() 拷贝三项资源，与父进程共享 mm	
	* clone() 取决于调用是的参数

### 3 系统调用 execve()

##### 3.1 execve() 执行流程
* 准备工作，获得可执行文件的路径名、参数、环境变量等信息
* 分派不同的目标文件给不同的代理人
* 检查目标文件的格式、属性信息及资源限制
* 出资进程的信号处理表
* 放弃从父进程继承下来的用户空间
* 关闭父进程原已打开的文件
* 装入程序
* 投入运行

##### 3.2 a.out 格式目标文件装载
1. 装入程序
	* 初始化 mm_struct 数据结构，为读入可执行文件的映象作准备
	* 确定进程在开始执行新的目标代码以后所具有的权限
	* 将文件的代码段与数据段映射到用户空间中，映射地址与装入地址一致； 为可执行文件的bss段分配空间并建立页面映射
	* 在用户空间的堆栈区顶部为进程建立一个虚存区间，并将执行参数及环境变量所占的物理页面与虚拟空间建立映射
	* 堆栈区的顶部为一个数组，数组的每一个元素都是一个页面，页面的下方，就是用户空间栈
	* 用户空间堆栈中设置好envp[]、argv[] 和 argc，将保存着(字符串形式)的参数和环境变量复制到用户空间的顶端
2. 投入运行
	* 设置各个寄存器，进程从系统调用返回时，就可以运行

### 4 系统调用 exit() 与 wait4()

##### 4.1 exit()
* 检查进程 pid 是否为 idle/init 进程，它们不允许退出
* 释放所有资源 (深释放，避免内核存储空间"泄露")
	* 存储空间、已打开的文件、工作目录、信号、实时定时器、信号量
* 当前进程状态改为 TASK_ZOMBIE，表示进程生命结束，不再接受调度
*  **进程控制块与内核栈未释放(两页)** ，通知父进程料理后事
	* PCB 中有统计信息，将统计信息并入父进程的统计信息，否则丢失
	* 不能造成内核栈空隙，使中断/异常在空隙中无法执行，必须保存到另一个进程开始运行后才能释放(情景P346)
* 把当前进程(生父)所有的子进程送进"孤儿院"，并嘱咐在将来 exit() 时发送一个信号给 init 进程
* 退出关系网(亲属关系双链队列)
* 调用 schedule() 选择一个进程运行

##### 4.2 wait4()
* 在当前进程的内核栈中非配一个 wait 数据结构，一旦返回，数据结构就不存在了(wait 情景P354)
* 遍历子进程队列，没有满足条件的子进程就进入阻塞状态
* 父进程因子进程发送 SIGCHLD 信号被唤醒，扫描子进程队列
* 父进程将子进程在用户态和内核态的运行时间统计数据并入自身
* 将子进程的残存资源(PCB & 内核栈)全部释放

生父与养父不同时：从养父队列脱离出来，挂入生父队列

### 进程的调度与切换


### TODO
* 阻塞？ linux 进程 等待队列
* ELF 格式文件的装载？

