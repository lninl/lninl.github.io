---
layout: post
title: "虚拟内存"
date: 2017-03-12
---

# 虚拟内存
---

[高端内存](http://ilinuxkernel.com/?p=1013)？

* 磁盘虚拟内存的管理？

* 物理内存的页式管理
* 虚拟内存的组织方式
* 虚拟地址到物理地址地址映射
* 缺页中断过程
* 物理内存与虚拟内存管理及关系
* 物理页的置换策略

### 1 物理内存的页式管理
最底层将整个物理空间划分为 4K(8K) 大小的页(page)。内核中的全局量 mem_map 指向 一个 page 数据机构的数组，每个 page 数据结构代表一个物理页面，整个数组就代表着系统中的全部物理页面。  
由于硬件限制，有些页面位于内存中特定的物理地址上，只能进行特定的任务。由硬件缺陷导致的寻址问题：

* 只能用某些特定的内存地址执行 DMA
* 内存的物理寻址比虚拟寻址范围大得多，有些内存不能永久的映射到内核空间

所有的物理页面划分成三个管理区：

* ZONE_DMA：小于 16MB 的地址
* ZONE_NORMAL：介于两者之间
* ZONE_HIGHMEM：大于 896MB 的地址

分配内存使用伙伴系统(无外部碎片)：

* 0~MAX_ORDER(10):最少 1 个物理页面，最多 10 个物理页面
* 双向链表链接相同大小物理页

![内存分配](http://i.imgur.com/SOOTIrS.png)

> todo：非匀质存储结构(NUMA)更高层的抽象：存储节点
 
### 2 虚拟内存的组织方式
![mm_struct](http://i.imgur.com/ThZ6l2u.png)

mm_strcut 是整个用户空间的抽象，底层由多个 VMA(`vm_area_struct`) 组成。

* VMA 区间的划分的依据：地址连续，属性相同
* VMA 的组织
	* 链表：根据虚拟地址由高到低连接
	* RB-tree：由虚拟地址寻找所属 VMA 时使用
* vm_ops 定义了一组函数指针(对不同 VMA 的附加操作), 其中 nopage 用于处理页面异常(page fault)
* 虚拟内存与磁盘的交互
	* 盘区交换
	* 将文件映射到用户空间(mmap)


### 3 地址映射

**地址映射失败(越界访问)的原因：**

* 映射关系未建立或已经撤销
* 访问页不在内存中
* 访问权限不符

**缺页中断的处理流程：**

**判断访问是否合法->分配虚拟内存->分配物理内存->建立映射关系**

* 判断是否为非法的访问越界
* 将地址按页面边界对齐，计算所需的页面数；需要判断是否超过资源限制
* 修改管理虚拟空间的数据结构(分配虚拟空间)
* 若页面目录项为空时，分配一个页面表，将页面表的起始地址及属性标志位写入页面目录项中
	* 分配页面表时先从缓冲池中分配
	* 缓冲池为空，从内存中申请 
* 分配一个物理内存页面，将物理页面连同所有的状态及标志位写入页面表项
* 映射完毕，重新执行因缺页导致执行失败的指令

### 4 物理页面的周转(内存页面与磁盘页面的交换：时间换空间)
* 磁盘页面的管理->页面交换项(与页面表项对应)
	* swapinfo_struct 数据结构，用于描述和管理页面交换的文件或设备
	* 释放磁盘页面只是在内存中的管理记录上操作，表示磁盘上的那个页面的内容已经作废，花费代价极小
* 页面表中表项的内容：
	* 页面在内存中时，页面表中的相应表项确定了地址的映射关系
	* 页面不在内存中时，则指明了物理页面的去向和所在
* 内存页面的周转：
	* 页面的分配、使用和回收
	* 盘区交换->回收
		* 并非所有的内存页面都可以交换出去，只有映射到用户空间的页面才会被换出
		* 所有的物理页面在系统空间中都有映射
		* 用户空间的页面：至少在一个进程的用户空间中有映射的页面
* 用户空间的页面种类：
	* 普通的用户空间页面，包括cs,ds,ss,及堆区
	* 通过系统调用mmap()映射到用户空间的已经打开文件的内容
	* 进程间的共享内存区
* 系统空间的页面种类：
	* 静态页面：内核代码和内核中全局量所占的内存页面，既不经过分配，也不会被释放
	* 动态页面：经过动态分配，到永远都保留在内核中，不会被交换出去 
* 常驻内存的页面按内容分类：
	* 一类是一旦使用完毕便无保存的价值，立即可释放、回收
		* 通过 kmalloc() 或 vmalloc() 分配的数据结构
		* 通过 alloc_page() 分配的内存页面
	* 另一类是虽然使用完毕，但内容仍有保存的价值，放入LRU队列
		* 缓存文件目录结构 dentry 的空间
		* 缓存 inode 结构的空间
		* 文件系统的 r/w 缓冲区
* **页面交换策略：**
	* LRU 准则选取内存页面交换
	* 避免页面的"抖动"，延迟释放(转入不活跃状态)
	* 脏页面的处理，脏页面 --转为--> 干净页面，干净页面的回收代价小
* **页面 换入/换出 的要点：**
	* 页面的使用计数 count
	* 页面管理区的空闲区队列 free_area，count == 0
	* 活跃页面队列 active_list，count >= 1
	* 不活跃"脏"页面队列 inactive_dirty_list, count == 0
	* 不活页"干净"页面队列 inactive_clean_list, count == 0
	

> **页面的“抖动”:** 整个系统的处理能力都被页面的 换入/换出 所饱和，而实际根本不能进行有效的运算和操作

### 5 物理页面的分配
* 单个页面可以从相应页面管理区的"不活跃干净页面"缓冲队列中回收
* 考察各个管理区的空闲页面总量，总量够时 rmqueue() 从该管理区中分配
* 给定分配策略中所有的页面管理区都失败
	* 降低对页面管理区中保持"水位"的要求
	* 考虑"不活跃干净页面"
* 管理区中的页面严重短缺
	* 唤醒内核线程 kswapd 设法换出一些页面
* **分配内存页面失败的原因**
	* 可分配页面的总量太少
		* 要求分配页面的进程睡眠等待
		* 唤醒内核线程 kswapd，完成运行后唤醒等待进程
	* 不能满足要求的页面块大小
		* 把"脏页"面"洗净"
		* 回收和释放"干净"页面拼装较大的页面块

### 6 页面的定期换出
* 解决问题：为避免缺页异常发生时，临时搜寻可供换出的内存页面；内核定期地检查并且预先将若干页面换出，腾出空间，以减轻系统在缺页中断发生时的负担
* kswapd：定期将页面换出；内核级线程，有自己的 PCB ，使用内核的空间，在系统相对空闲时受内核调度；
* kswapd 受内核调度的全过程：
	* 初始化：系统初始化期间调用 kswapd_init()
		* 根据物理内存本身的大小确定"预读"磁盘的页面数量
		* 创建线程 kswapd
	* 无限循环
		* 循环末尾调用interruptible_sleep_on_timeout()进入睡眠
		* 经过 1 秒钟后又调用 kswapd 继续执行
	* 执行任务(活跃->不活跃，脏->干净)
		* 第一部分在物理页面已经短缺的情况下进行，预先找到若干页面，将页面的映射断开，使物理页面从活跃状态转入不活跃状态
		* 第二部分每次执行，吧已经处于不活跃状态的"脏"页面写入交换设备，成为不活跃"干净"页面继续缓冲，或进一步回收乘为空闲页面

### 7 页面的换入
* 地址的映射已经建立，但相应的物理页面不在内存中
	* 映射过程首先检查页面表项或目录项中的 P 标志位
	* 原因是页面不在内存，还是映射尚未建立， pte_none() 检查表项
		* 全 0 表示映射尚未建立
		* 非空，表示映射已经建立，只是物理页面不在内存中
* 页面换入的流程：
	* 首先查看**换入/换出队列**，判断页面是否尚未被释放
	* 页面已经释放：
		* **预读**多个页面，暂时链入活跃页面队列及换入/换出队列
		* 分配不到足够的内存页面时，只读一个页面

---

* 分配策略 gfp_mask ?

内存页面的分配和释放：物理介质

页面的换入换出：内容

内核中内存分配的函数 vmalloc()、 vfree()
在内核空间分配，不会被 kswapd 换出

### 参考文献
* Linux 内核源代码情景分析

